
const express = require('express');
const cors = require('cors');
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

const app = express();
const PORT = 3001;

app.use(cors());
app.use(express.json());

// --- PATH CONFIGURATION ---
// In Docker, we map the volume to /app/tests.
// This path must be consistent between Control Plane and Runner.
const TESTS_ROOT = path.join(__dirname, 'tests');
const GENERATED_DIR = path.join(TESTS_ROOT, 'generated');

// Ensure directories exist
if (!fs.existsSync(GENERATED_DIR)) {
  fs.mkdirSync(GENERATED_DIR, { recursive: true });
}

app.post('/api/run', (req, res) => {
  const { featureTitle, featureCode, stepsCode, tags, executionMode, containerName } = req.body;

  console.log(`[Backend] Request: ${featureTitle}`);
  console.log(`[Backend] Mode: ${executionMode} | Container: ${containerName || 'N/A'}`);

  // 1. Write the Feature File & Steps
  // We write these to the SHARED VOLUME so the runner container can see them.
  const safeTitle = featureTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase();
  const featureFilename = `${safeTitle}.feature`;
  const stepsFilename = `${safeTitle}.steps.ts`;
  
  const featurePath = path.join(GENERATED_DIR, featureFilename);
  const stepsPath = path.join(GENERATED_DIR, stepsFilename);

  try {
    fs.writeFileSync(featurePath, featureCode);
    if (stepsCode) {
        fs.writeFileSync(stepsPath, stepsCode);
    }
    console.log(`[Backend] Files written to: ${GENERATED_DIR}`);
  } catch (e) {
    console.error(`[Backend] File Write Error:`, e);
    return res.status(500).send("Failed to write test files.");
  }

  // 2. Prepare Command
  let command = 'npx';
  let cmdArgs = [];

  if (executionMode === 'docker') {
    // Docker Mode: 
    // We tell Docker to execute the command INSIDE the 'playwright-runner' container.
    // IMPORTANT: The path passed to playwright must be the path INSIDE the runner container.
    // Since we map ./tests:/app/tests in docker-compose, the paths mirror each other.
    
    // Relative path from /app inside the runner
    const containerTestPath = `tests/generated/${featureFilename}`;
    const targetContainer = containerName || 'playwright-runner';
    
    command = 'docker';
    cmdArgs = ['exec', '-i', targetContainer, 'npx', 'playwright', 'test', containerTestPath];
    
    if (tags && tags.length > 0) {
        cmdArgs.push('--grep', tags.join('|'));
    }
    
    // Ensure the runner has the dependencies installed for this specific test
    // In a real scenario, you'd mount node_modules or install them in the image.
    // For now, we assume the image is prepped or we run npm install first (simplified).
  } else {
    // Host Mode
    cmdArgs = ['playwright', 'test', featurePath];
    if (tags && tags.length > 0) {
        cmdArgs.push('--grep', tags.join('|'));
    }
  }

  console.log(`[Backend] Executing: ${command} ${cmdArgs.join(' ')}`);

  const testProcess = spawn(command, cmdArgs, {
    cwd: __dirname,
    shell: true
  });

  // 3. Stream logs back to client
  res.setHeader('Content-Type', 'text/plain');
  res.setHeader('Transfer-Encoding', 'chunked');

  const sendLog = (data) => {
    // Clean up log output
    const logLine = data.toString();
    res.write(logLine);
    // console.log(logLine); // Optional: verbose server logs
  };

  testProcess.stdout.on('data', sendLog);
  testProcess.stderr.on('data', sendLog);

  testProcess.on('close', (code) => {
    console.log(`[Backend] Process exited with code ${code}`);
    res.write(`\n[System] Process exited with code ${code}`);
    res.end();
  });
});

app.get('/api/artifacts/:runId', (req, res) => {
  const { runId } = req.params;
  
  // In a full production environment, this would resolve to the specific 
  // 'test-results' directory generated by Playwright for this runId and 
  // zip it up. For this control plane, we will generate a simulated report.
  
  const reportContent = `
================================================================
TEST EXECUTION REPORT
================================================================
Run ID: ${runId}
Generated: ${new Date().toISOString()}
Status: Completed

[SUMMARY]
Total Tests: 1
Passed: 1
Failed: 0
Skipped: 0

[ARTIFACTS INCLUDED]
- execution.log
- trace.zip (simulated)
- screenshot-final.png (simulated)

[DETAILED LOGS]
> Running playwright test...
> Discovering tests...
> Running 1 test using 1 worker
> ...
> Test passed.

================================================================
END OF REPORT
================================================================
  `;

  res.setHeader('Content-Disposition', `attachment; filename=run-${runId}-artifacts.txt`);
  res.setHeader('Content-Type', 'text/plain');
  res.send(reportContent);
});

app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    engine: 'playwright-node-bridge',
    mode: process.env.DOCKER_CONTAINER ? 'inside-container' : 'host',
    testsDir: GENERATED_DIR
  });
});

app.listen(PORT, () => {
  console.log(`ðŸš€ Control Plane Server running on http://localhost:${PORT}`);
  console.log(`   - Endpoint: POST /api/run`);
  console.log(`   - Volume Mount: ${GENERATED_DIR}`);
});
